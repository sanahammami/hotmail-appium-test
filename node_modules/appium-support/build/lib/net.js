"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.uploadFile = uploadFile;
exports.downloadFile = downloadFile;

require("source-map-support/register");

var _lodash = _interopRequireDefault(require("lodash"));

var _fs = _interopRequireDefault(require("./fs"));

var _url = _interopRequireDefault(require("url"));

var _bluebird = _interopRequireDefault(require("bluebird"));

var _util = require("./util");

var _logger = _interopRequireDefault(require("./logger"));

var _jsftp = _interopRequireDefault(require("jsftp"));

var _timing = _interopRequireDefault(require("./timing"));

var _axios = _interopRequireDefault(require("axios"));

var _formData = _interopRequireDefault(require("form-data"));

function toAxiosAuth(auth) {
  if (!_lodash.default.isPlainObject(auth)) {
    return null;
  }

  const axiosAuth = {
    username: auth.username || auth.user,
    password: auth.password || auth.pass
  };
  return axiosAuth.username && axiosAuth.password ? axiosAuth : null;
}

async function uploadFileToHttp(localFileStream, parsedUri, uploadOptions = {}) {
  const {
    method = 'POST',
    timeout = 5000,
    headers,
    auth,
    fileFieldName = 'file',
    formFields
  } = uploadOptions;
  const {
    protocol,
    href
  } = parsedUri;
  const requestOpts = {
    url: href,
    method,
    timeout
  };
  const axiosAuth = toAxiosAuth(auth);

  if (axiosAuth) {
    requestOpts.auth = axiosAuth;
  }

  const form = new _formData.default();
  form.append(fileFieldName, localFileStream);

  if (formFields) {
    let pairs = [];

    if (_lodash.default.isArray(formFields)) {
      pairs = formFields;
    } else if (_lodash.default.isPlainObject(formFields)) {
      pairs = _lodash.default.toPairs(formFields);
    }

    for (const [key, value] of pairs) {
      if (_lodash.default.toLower(key) !== _lodash.default.toLower(fileFieldName)) {
        form.append(key, value);
      }
    }
  }

  requestOpts.data = form;
  requestOpts.headers = Object.assign({}, _lodash.default.isPlainObject(headers) ? headers : {}, form.getHeaders());

  _logger.default.debug(`${protocol} upload options: ${JSON.stringify(requestOpts)}`);

  await (0, _axios.default)(requestOpts);
}

async function uploadFileToFtp(localFileStream, parsedUri, uploadOptions = {}) {
  const {
    auth,
    user,
    pass
  } = uploadOptions;
  const {
    hostname,
    port,
    protocol,
    pathname
  } = parsedUri;
  const ftpOpts = {
    host: hostname,
    port: port || 21
  };

  if ((auth === null || auth === void 0 ? void 0 : auth.user) && (auth === null || auth === void 0 ? void 0 : auth.pass) || user && pass) {
    ftpOpts.user = (auth === null || auth === void 0 ? void 0 : auth.user) || user;
    ftpOpts.pass = (auth === null || auth === void 0 ? void 0 : auth.pass) || pass;
  }

  _logger.default.debug(`${protocol} upload options: ${JSON.stringify(ftpOpts)}`);

  return await new _bluebird.default((resolve, reject) => {
    new _jsftp.default(ftpOpts).put(localFileStream, pathname, err => {
      if (err) {
        reject(err);
      } else {
        resolve();
      }
    });
  });
}

async function uploadFile(localPath, remoteUri, uploadOptions = {}) {
  if (!(await _fs.default.exists(localPath))) {
    throw new Error(`'${localPath}' does not exists or is not accessible`);
  }

  const {
    isMetered = true
  } = uploadOptions;

  const parsedUri = _url.default.parse(remoteUri);

  const {
    size
  } = await _fs.default.stat(localPath);

  if (isMetered) {
    _logger.default.info(`Uploading '${localPath}' of ${(0, _util.toReadableSizeString)(size)} size to '${remoteUri}'...`);
  }

  const timer = new _timing.default().start();

  if (['http:', 'https:'].includes(parsedUri.protocol)) {
    await uploadFileToHttp(_fs.default.createReadStream(localPath), parsedUri, uploadOptions);
  } else if (parsedUri.protocol === 'ftp:') {
    await uploadFileToFtp(_fs.default.createReadStream(localPath), parsedUri, uploadOptions);
  } else {
    throw new Error(`Cannot upload the file at '${localPath}' to '${remoteUri}'. ` + `Unsupported remote protocol '${parsedUri.protocol}'. ` + `Only http/https and ftp/ftps protocols are supported.`);
  }

  if (isMetered) {
    _logger.default.info(`Uploaded '${localPath}' of ${(0, _util.toReadableSizeString)(size)} size in ${timer.getDuration().asSeconds.toFixed(3)}s`);
  }
}

async function downloadFile(remoteUrl, dstPath, downloadOptions = {}) {
  const {
    isMetered = true,
    auth,
    timeout = 5000,
    headers
  } = downloadOptions;
  const requestOpts = {
    url: remoteUrl,
    responseType: 'stream',
    timeout
  };
  const axiosAuth = toAxiosAuth(auth);

  if (axiosAuth) {
    requestOpts.auth = axiosAuth;
  }

  if (_lodash.default.isPlainObject(headers)) {
    requestOpts.headers = headers;
  }

  const timer = new _timing.default().start();

  try {
    const writer = _fs.default.createWriteStream(dstPath);

    const responseStream = (await (0, _axios.default)(requestOpts)).data;
    responseStream.pipe(writer);
    await new _bluebird.default((resolve, reject) => {
      responseStream.once('error', reject);
      writer.once('finish', resolve);
      writer.once('error', e => {
        responseStream.unpipe(writer);
        reject(e);
      });
    });
  } catch (err) {
    throw new Error(`Cannot download the file from ${remoteUrl}: ${err.message}`);
  }

  if (!isMetered) {
    return;
  }

  const secondsElapsed = timer.getDuration().asSeconds;
  const {
    size
  } = await _fs.default.stat(dstPath);

  _logger.default.debug(`${remoteUrl} (${(0, _util.toReadableSizeString)(size)}) ` + `has been downloaded to '${dstPath}' in ${secondsElapsed.toFixed(3)}s`);

  if (secondsElapsed >= 2) {
    const bytesPerSec = Math.floor(size / secondsElapsed);

    _logger.default.debug(`Approximate download speed: ${(0, _util.toReadableSizeString)(bytesPerSec)}/s`);
  }
}require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9uZXQuanMiXSwibmFtZXMiOlsidG9BeGlvc0F1dGgiLCJhdXRoIiwiXyIsImlzUGxhaW5PYmplY3QiLCJheGlvc0F1dGgiLCJ1c2VybmFtZSIsInVzZXIiLCJwYXNzd29yZCIsInBhc3MiLCJ1cGxvYWRGaWxlVG9IdHRwIiwibG9jYWxGaWxlU3RyZWFtIiwicGFyc2VkVXJpIiwidXBsb2FkT3B0aW9ucyIsIm1ldGhvZCIsInRpbWVvdXQiLCJoZWFkZXJzIiwiZmlsZUZpZWxkTmFtZSIsImZvcm1GaWVsZHMiLCJwcm90b2NvbCIsImhyZWYiLCJyZXF1ZXN0T3B0cyIsInVybCIsImZvcm0iLCJGb3JtRGF0YSIsImFwcGVuZCIsInBhaXJzIiwiaXNBcnJheSIsInRvUGFpcnMiLCJrZXkiLCJ2YWx1ZSIsInRvTG93ZXIiLCJkYXRhIiwiT2JqZWN0IiwiYXNzaWduIiwiZ2V0SGVhZGVycyIsImxvZyIsImRlYnVnIiwiSlNPTiIsInN0cmluZ2lmeSIsInVwbG9hZEZpbGVUb0Z0cCIsImhvc3RuYW1lIiwicG9ydCIsInBhdGhuYW1lIiwiZnRwT3B0cyIsImhvc3QiLCJCIiwicmVzb2x2ZSIsInJlamVjdCIsIkZ0cCIsInB1dCIsImVyciIsInVwbG9hZEZpbGUiLCJsb2NhbFBhdGgiLCJyZW1vdGVVcmkiLCJmcyIsImV4aXN0cyIsIkVycm9yIiwiaXNNZXRlcmVkIiwicGFyc2UiLCJzaXplIiwic3RhdCIsImluZm8iLCJ0aW1lciIsIlRpbWVyIiwic3RhcnQiLCJpbmNsdWRlcyIsImNyZWF0ZVJlYWRTdHJlYW0iLCJnZXREdXJhdGlvbiIsImFzU2Vjb25kcyIsInRvRml4ZWQiLCJkb3dubG9hZEZpbGUiLCJyZW1vdGVVcmwiLCJkc3RQYXRoIiwiZG93bmxvYWRPcHRpb25zIiwicmVzcG9uc2VUeXBlIiwid3JpdGVyIiwiY3JlYXRlV3JpdGVTdHJlYW0iLCJyZXNwb25zZVN0cmVhbSIsInBpcGUiLCJvbmNlIiwiZSIsInVucGlwZSIsIm1lc3NhZ2UiLCJzZWNv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LE9BQWYsQ0FBdUIsQ0FBdkIsQ0FBMEIsR0FEdEU7O0FBRUEsTUFBSWMsY0FBYyxJQUFJLENBQXRCLEVBQXlCO0FBQ3ZCLFVBQU1DLFdBQVcsR0FBR0MsSUFBSSxDQUFDQyxLQUFMLENBQVczQixJQUFJLEdBQUd3QixjQUFsQixDQUFwQjs7QUFDQWhELG9CQUFJQyxLQUFKLENBQVcsK0JBQThCLGdDQUFxQmdELFdBQXJCLENBQWtDLElBQTNFO0FBQ0Q7QUFDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgZnMgZnJvbSAnLi9mcyc7XG5pbXBvcnQgdXJsIGZyb20gJ3VybCc7XG5pbXBvcnQgQiBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgeyB0b1JlYWRhYmxlU2l6ZVN0cmluZyB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgbG9nIGZyb20gJy4vbG9nZ2VyJztcbmltcG9ydCBGdHAgZnJvbSAnanNmdHAnO1xuaW1wb3J0IFRpbWVyIGZyb20gJy4vdGltaW5nJztcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG5pbXBvcnQgRm9ybURhdGEgZnJvbSAnZm9ybS1kYXRhJztcblxuXG5mdW5jdGlvbiB0b0F4aW9zQXV0aCAoYXV0aCkge1xuICBpZiAoIV8uaXNQbGFpbk9iamVjdChhdXRoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgYXhpb3NBdXRoID0ge1xuICAgIHVzZXJuYW1lOiBhdXRoLnVzZXJuYW1lIHx8IGF1dGgudXNlcixcbiAgICBwYXNzd29yZDogYXV0aC5wYXNzd29yZCB8fCBhdXRoLnBhc3MsXG4gIH07XG4gIHJldHVybiAoYXhpb3NBdXRoLnVzZXJuYW1lICYmIGF4aW9zQXV0aC5wYXNzd29yZCkgPyBheGlvc0F1dGggOiBudWxsO1xufVxuXG5hc3luYyBmdW5jdGlvbiB1cGxvYWRGaWxlVG9IdHRwIChsb2NhbEZpbGVTdHJlYW0sIHBhcnNlZFVyaSwgdXBsb2FkT3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBtZXRob2QgPSAnUE9TVCcsXG4gICAgdGltZW91dCA9IDUwMDAsXG4gICAgaGVhZGVycyxcbiAgICBhdXRoLFxuICAgIGZpbGVGaWVsZE5hbWUgPSAnZmlsZScsXG4gICAgZm9ybUZpZWxkcyxcbiAgfSA9IHVwbG9hZE9wdGlvbnM7XG4gIGNvbnN0IHtcbiAgICBwcm90b2NvbCxcbiAgICBocmVmLFxuICB9ID0gcGFyc2VkVXJpO1xuXG4gIGNvbnN0IHJlcXVlc3RPcHRzID0ge1xuICAgIHVybDogaHJlZixcbiAgICBtZXRob2QsXG4gICAgdGltZW91dCxcbiAgfTtcbiAgY29uc3QgYXhpb3NBdXRoID0gdG9BeGlvc0F1dGgoYXV0aCk7XG4gIGlmIChheGlvc0F1dGgpIHtcbiAgICByZXF1ZXN0T3B0cy5hdXRoID0gYXhpb3NBdXRoO1xuICB9XG4gIGNvbnN0IGZvcm0gPSBuZXcgRm9ybURhdGEoKTtcbiAgZm9ybS5hcHBlbmQoZmlsZUZpZWxkTmFtZSwgbG9jYWxGaWxlU3RyZWFtKTtcbiAgaWYgKGZvcm1GaWVsZHMpIHtcbiAgICBsZXQgcGFpcnMgPSBbXTtcbiAgICBpZiAoXy5pc0FycmF5KGZvcm1GaWVsZHMpKSB7XG4gICAgICBwYWlycyA9IGZvcm1GaWVsZHM7XG4gICAgfSBlbHNlIGlmIChfLmlzUGxhaW5PYmplY3QoZm9ybUZpZWxkcykpIHtcbiAgICAgIHBhaXJzID0gXy50b1BhaXJzKGZvcm1GaWVsZHMpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBwYWlycykge1xuICAgICAgaWYgKF8udG9Mb3dlcihrZXkpICE9PSBfLnRvTG93ZXIoZmlsZUZpZWxkTmFtZSkpIHtcbiAgICAgICAgZm9ybS5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlcXVlc3RPcHRzLmRhdGEgPSBmb3JtO1xuICByZXF1ZXN0T3B0cy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgXy5pc1BsYWluT2JqZWN0KGhlYWRlcnMpID8gaGVhZGVycyA6IHt9LCBmb3JtLmdldEhlYWRlcnMoKSk7XG5cbiAgbG9nLmRlYnVnKGAke3Byb3RvY29sfSB1cGxvYWQgb3B0aW9uczogJHtKU09OLnN0cmluZ2lmeShyZXF1ZXN0T3B0cyl9YCk7XG4gIGF3YWl0IGF4aW9zKHJlcXVlc3RPcHRzKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gdXBsb2FkRmlsZVRvRnRwIChsb2NhbEZpbGVTdHJlYW0sIHBhcnNlZFVyaSwgdXBsb2FkT3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBhdXRoLFxuICAgIHVzZXIsXG4gICAgcGFzcyxcbiAgfSA9IHVwbG9hZE9wdGlvbnM7XG4gIGNvbnN0IHtcbiAgICBob3N0bmFtZSxcbiAgICBwb3J0LFxuICAgIHByb3RvY29sLFxuICAgIHBhdGhuYW1lLFxuICB9ID0gcGFyc2VkVXJpO1xuXG4gIGNvbnN0IGZ0cE9wdHMgPSB7XG4gICAgaG9zdDogaG9zdG5hbWUsXG4gICAgcG9ydDogcG9ydCB8fCAyMSxcbiAgfTtcbiAgaWYgKChhdXRoPy51c2VyICYmIGF1dGg/LnBhc3MpIHx8ICh1c2VyICYmIHBhc3MpKSB7XG4gICAgZnRwT3B0cy51c2VyID0gYXV0aD8udXNlciB8fCB1c2VyO1xuICAgIGZ0cE9wdHMucGFzcyA9IGF1dGg/LnBhc3MgfHwgcGFzcztcbiAgfVxuICBsb2cuZGVidWcoYCR7cHJvdG9jb2x9IHVwbG9hZCBvcHRpb25zOiAke0pTT04uc3RyaW5naWZ5KGZ0cE9wdHMpfWApO1xuICByZXR1cm4gYXdhaXQgbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIG5ldyBGdHAoZnRwT3B0cykucHV0KGxvY2FsRmlsZVN0cmVhbSwgcGF0aG5hbWUsIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEF1dGhDcmVkZW50aWFsc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IHVzZXIgLSBOb24tZW1wdHkgdXNlciBuYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcGFzcyAtIE5vbi1lbXB0eSBwYXNzd29yZFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRnRwVXBsb2FkT3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSBpc01ldGVyZWQgW3RydWVdIC0gV2hldGhlciB0byBsb2cgdGhlIGFjdHVhbCB1cGxvYWQgcGVyZm9ybWFuY2VcbiAqIChlLmcuIHRpbWluZ3MgYW5kIHNwZWVkKVxuICogQHByb3BlcnR5IHtBdXRoQ3JlZGVudGlhbHN9IGF1dGhcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEh0dHBVcGxvYWRPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzTWV0ZXJlZCBbdHJ1ZV0gLSBXaGV0aGVyIHRvIGxvZyB0aGUgYWN0dWFsIHVwbG9hZCBwZXJmb3JtYW5jZVxuICogKGUuZy4gdGltaW5ncyBhbmQgc3BlZWQpXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWV0aG9kIFtQT1NUXSAtIFRoZSBIVFRQIG1ldGhvZCB1c2VkIGZvciBmaWxlIHVwbG9hZFxuICogQHByb3BlcnR5IHtBdXRoQ3JlZGVudGlhbHN9IGF1dGhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lb3V0IFs1MDAwXSAtIFRoZSBhY3R1YWwgcmVxdWVzdCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGhlYWRlcnMgLSBBZGRpdGlvbmFsIHJlcXVlc3QgaGVhZGVycyBtYXBwaW5nXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZmlsZUZpZWxkTmFtZSBbZmlsZV0gLSBUaGUgbmFtZSBvZiB0aGUgZm9ybSBmaWVsZCBjb250YWluaW5nIHRoZSBmaWxlXG4gKiBjb250ZW50IHRvIGJlIHVwbG9hZGVkXG4gKiBAcHJvcGVydHkge0FycmF5PFBhaXI+fE9iamVjdH0gZm9ybUZpZWxkcyAtIFRoZSBhZGRpdGlvbmFsIGZvcm0gZmllbGRzXG4gKiB0byBiZSBpbmNsdWRlZCBpbnRvIHRoZSB1cGxvYWQgcmVxdWVzdC4gVGhpcyBwcm9wZXJ0eSBpcyBvbmx5IGNvbnNpZGVyZWQgaWZcbiAqIGBmaWxlRmllbGROYW1lYCBpcyBzZXRcbiAqL1xuXG4vKipcbiAqIFVwbG9hZHMgdGhlIGdpdmVuIGZpbGUgdG8gYSByZW1vdGUgbG9jYXRpb24uIEhUVFAoUykgYW5kIEZUUFxuICogcHJvdG9jb2xzIGFyZSBzdXBwb3J0ZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsUGF0aCAtIFRoZSBwYXRoIHRvIGEgZmlsZSBvbiB0aGUgbG9jYWwgc3RvcmFnZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVVcmkgLSBUaGUgcmVtb3RlIFVSSSB0byB1cGxvYWQgdGhlIGZpbGUgdG8uXG4gKiBAcGFyYW0gez9GdHBVcGxvYWRPcHRpb25zfEh0dHBVcGxvYWRPcHRpb25zfSB1cGxvYWRPcHRpb25zXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHVwbG9hZEZpbGUgKGxvY2FsUGF0aCwgcmVtb3RlVXJpLCB1cGxvYWRPcHRpb25zID0ge30pIHtcbiAgaWYgKCFhd2FpdCBmcy5leGlzdHMobG9jYWxQYXRoKSkge1xuICAgIHRocm93IG5ldyBFcnJvciAoYCcke2xvY2FsUGF0aH0nIGRvZXMgbm90IGV4aXN0cyBvciBpcyBub3QgYWNjZXNzaWJsZWApO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIGlzTWV0ZXJlZCA9IHRydWUsXG4gIH0gPSB1cGxvYWRPcHRpb25zO1xuXG4gIGNvbnN0IHBhcnNlZFVyaSA9IHVybC5wYXJzZShyZW1vdGVVcmkpO1xuICBjb25zdCB7c2l6ZX0gPSBhd2FpdCBmcy5zdGF0KGxvY2FsUGF0aCk7XG4gIGlmIChpc01ldGVyZWQpIHtcbiAgICBsb2cuaW5mbyhgVXBsb2FkaW5nICcke2xvY2FsUGF0aH0nIG9mICR7dG9SZWFkYWJsZVNpemVTdHJpbmcoc2l6ZSl9IHNpemUgdG8gJyR7cmVtb3RlVXJpfScuLi5gKTtcbiAgfVxuICBjb25zdCB0aW1lciA9IG5ldyBUaW1lcigpLnN0YXJ0KCk7XG4gIGlmIChbJ2h0dHA6JywgJ2h0dHBzOiddLmluY2x1ZGVzKHBhcnNlZFVyaS5wcm90b2NvbCkpIHtcbiAgICBhd2FpdCB1cGxvYWRGaWxlVG9IdHRwKGZzLmNyZWF0ZVJlYWRTdHJlYW0obG9jYWxQYXRoKSwgcGFyc2VkVXJpLCB1cGxvYWRPcHRpb25zKTtcbiAgfSBlbHNlIGlmIChwYXJzZWRVcmkucHJvdG9jb2wgPT09ICdmdHA6Jykge1xuICAgIGF3YWl0IHVwbG9hZEZpbGVUb0Z0cChmcy5jcmVhdGVSZWFkU3RyZWFtKGxvY2FsUGF0aCksIHBhcnNlZFVyaSwgdXBsb2FkT3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgdXBsb2FkIHRoZSBmaWxlIGF0ICcke2xvY2FsUGF0aH0nIHRvICcke3JlbW90ZVVyaX0nLiBgICtcbiAgICAgIGBVbnN1cHBvcnRlZCByZW1vdGUgcHJvdG9jb2wgJyR7cGFyc2VkVXJpLnByb3RvY29sfScuIGAgK1xuICAgICAgYE9ubHkgaHR0cC9odHRwcyBhbmQgZnRwL2Z0cHMgcHJvdG9jb2xzIGFyZSBzdXBwb3J0ZWQuYCk7XG4gIH1cbiAgaWYgKGlzTWV0ZXJlZCkge1xuICAgIGxvZy5pbmZvKGBVcGxvYWRlZCAnJHtsb2NhbFBhdGh9JyBvZiAke3RvUmVhZGFibGVTaXplU3RyaW5nKHNpemUpfSBzaXplIGluICR7dGltZXIuZ2V0RHVyYXRpb24oKS5hc1NlY29uZHMudG9GaXhlZCgzKX1zYCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEb3dubG9hZE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNNZXRlcmVkIFt0cnVlXSAtIFdoZXRoZXIgdG8gbG9nIHRoZSBhY3R1YWwgZG93bmxvYWQgcGVyZm9ybWFuY2VcbiAqIChlLmcuIHRpbWluZ3MgYW5kIHNwZWVkKVxuICogQHByb3BlcnR5IHtBdXRoQ3JlZGVudGlhbHN9IGF1dGhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lb3V0IFs1MDAwXSAtIFRoZSBhY3R1YWwgcmVxdWVzdCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGhlYWRlcnMgLSBSZXF1ZXN0IGhlYWRlcnMgbWFwcGluZ1xuICovXG5cbi8qKlxuICogRG93bmxvYWRzIHRoZSBnaXZlbiBmaWxlIHZpYSBIVFRQKFMpXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVVybCAtIFRoZSByZW1vdGUgdXJsXG4gKiBAcGFyYW0ge3N0cmluZ30gZHN0UGF0aCAtIFRoZSBsb2NhbCBwYXRoIHRvIGRvd25sb2FkIHRoZSBmaWxlIHRvXG4gKiBAcGFyYW0gez9Eb3dubG9hZE9wdGlvbnN9IGRvd25sb2FkT3B0aW9uc1xuICogQHRocm93cyB7RXJyb3J9IElmIGRvd25sb2FkIG9wZXJhdGlvbiBmYWlsc1xuICovXG5hc3luYyBmdW5jdGlvbiBkb3dubG9hZEZpbGUgKHJlbW90ZVVybCwgZHN0UGF0aCwgZG93bmxvYWRPcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGlzTWV0ZXJlZCA9IHRydWUsXG4gICAgYXV0aCxcbiAgICB0aW1lb3V0ID0gNTAwMCxcbiAgICBoZWFkZXJzLFxuICB9ID0gZG93bmxvYWRPcHRpb25zO1xuXG4gIGNvbnN0IHJlcXVlc3RPcHRzID0ge1xuICAgIHVybDogcmVtb3RlVXJsLFxuICAgIHJlc3BvbnNlVHlwZTogJ3N0cmVhbScsXG4gICAgdGltZW91dCxcbiAgfTtcbiAgY29uc3QgYXhpb3NBdXRoID0gdG9BeGlvc0F1dGgoYXV0aCk7XG4gIGlmIChheGlvc0F1dGgpIHtcbiAgICByZXF1ZXN0T3B0cy5hdXRoID0gYXhpb3NBdXRoO1xuICB9XG4gIGlmIChfLmlzUGxhaW5PYmplY3QoaGVhZGVycykpIHtcbiAgICByZXF1ZXN0T3B0cy5oZWFkZXJzID0gaGVhZGVycztcbiAgfVxuXG4gIGNvbnN0IHRpbWVyID0gbmV3IFRpbWVyKCkuc3RhcnQoKTtcbiAgdHJ5IHtcbiAgICBjb25zdCB3cml0ZXIgPSBmcy5jcmVhdGVXcml0ZVN0cmVhbShkc3RQYXRoKTtcbiAgICBjb25zdCByZXNwb25zZVN0cmVhbSA9IChhd2FpdCBheGlvcyhyZXF1ZXN0T3B0cykpLmRhdGE7XG4gICAgcmVzcG9uc2VTdHJlYW0ucGlwZSh3cml0ZXIpO1xuXG4gICAgYXdhaXQgbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcmVzcG9uc2VTdHJlYW0ub25jZSgnZXJyb3InLCByZWplY3QpO1xuICAgICAgd3JpdGVyLm9uY2UoJ2ZpbmlzaCcsIHJlc29sdmUpO1xuICAgICAgd3JpdGVyLm9uY2UoJ2Vycm9yJywgKGUpID0+IHtcbiAgICAgICAgcmVzcG9uc2VTdHJlYW0udW5waXBlKHdyaXRlcik7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBkb3dubG9hZCB0aGUgZmlsZSBmcm9tICR7cmVtb3RlVXJsfTogJHtlcnIubWVzc2FnZX1gKTtcbiAgfVxuICBpZiAoIWlzTWV0ZXJlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHNlY29uZHNFbGFwc2VkID0gdGltZXIuZ2V0RHVyYXRpb24oKS5hc1NlY29uZHM7XG4gIGNvbnN0IHtzaXplfSA9IGF3YWl0IGZzLnN0YXQoZHN0UGF0aCk7XG4gIGxvZy5kZWJ1ZyhgJHtyZW1vdGVVcmx9ICgke3RvUmVhZGFibGVTaXplU3RyaW5nKHNpemUpfSkgYCArXG4gICAgYGhhcyBiZWVuIGRvd25sb2FkZWQgdG8gJyR7ZHN0UGF0aH0nIGluICR7c2Vjb25kc0VsYXBzZWQudG9GaXhlZCgzKX1zYCk7XG4gIGlmIChzZWNvbmRzRWxhcHNlZCA+PSAyKSB7XG4gICAgY29uc3QgYnl0ZXNQZXJTZWMgPSBNYXRoLmZsb29yKHNpemUgLyBzZWNvbmRzRWxhcHNlZCk7XG4gICAgbG9nLmRlYnVnKGBBcHByb3hpbWF0ZSBkb3dubG9hZCBzcGVlZDogJHt0b1JlYWRhYmxlU2l6ZVN0cmluZyhieXRlc1BlclNlYyl9L3NgKTtcbiAgfVxufVxuXG5leHBvcnQgeyB1cGxvYWRGaWxlLCBkb3dubG9hZEZpbGUgfTtcbiJdLCJmaWxlIjoibGliL25ldC5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLiJ9
